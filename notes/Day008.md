# Day 8
### Coalesced Global Memory Access
- GPU is the most efficient when multiple threads read or write, contiguous memory locations. 
- Global memory is accessed via 32-byte memory transactions. 
- If, threads in same warp, need to access the contiguous memory locations, it's more efficient due to coalescing. 
- If threads need to access from more strided memory locations, more memory transactions are requires losing efficiency. 
- Best way to achieve coalesced memory access is to maximize the ratio of bytes used to bytes transferred. 
- !! One of the Most important techniques for writing performant CUDA kernels. 


### Matrix Transpose Example using Global Memory
Code in `008_matrix_transpose.cu`

Is this achieving coalesced global memory access??

1.
    - In 2D thread block, X index moves fastest. So, consecutive values of `threadIdx.x` should be accessing consecutive elements of memory. 
    -  `threadIdx.x` appears in `col` which is the second argument to `INDX`. So, consecutive threads are reading consecutive values of `a`. So, read of `a` is perfectly coalesced. 

2. Writing of `c`:
    - Writing of C isn't coalesced. Why? 
    - Writing to `C`, are `ld` elements apart from each other. `col` is first argument of `INDX` macro. 
    - As, ld increases by 1, memory location increments by `ld`. When `ld` is larger than 32, the worst case scenario is observed.  
